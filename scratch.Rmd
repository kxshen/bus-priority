---
title: "11.S953: Bus Priority Measures"
output: rmarkdown::github_document
always_allow_html: true

---
The purpose of this memo is in assessing the affectiveness of the recent bus priority measure implemented by the MBTA. 
```{r include=FALSE}
#Libraries...?
library(tidytransit)
library(tidyverse)
library(leaflet)
library(lubridate)
library(sf)
library(geojsonsf)
```

# Import data
First, start with one route, and compare average travel times before and after implementation

Use GTFS to get (lat,long) for stop id's, and other things for the real map. 
```{r}
#GTFS
mbta_gtfs = read_gtfs('data/MBTA_GTFS_Jan_2019.zip')#runtime is long on importing GTFS feed
```
# Visualize the map
```{r}
dat = read.csv(file = 'data/Broadway/R101_in.csv')

#Find coordinates of important stops
stopnames = dat %>% select(stopid) %>% unique()
stops_cut = filter(mbta_gtfs$stops, as.numeric(stop_code) %in% stopnames$stopid) %>% arrange(stop_lon)

#recreate the methodology from class, but only display the better bus lanes and the corresponding stops
geo1 = st_multipoint(cbind(stops_cut$stop_lon, stops_cut$stop_lat)) %>% st_sfc %>% st_sf# stop points
selected_shape_ids = mbta_gtfs$trips %>% 
  filter(as.numeric(route_id) %in% 101) %>% 
  select(shape_id) %>% 
  unique()
selected_shapes = mbta_gtfs$shapes %>%
  filter(shape_id %in% selected_shape_ids$shape_id) %>% 
  arrange(shape_id, shape_pt_sequence)

ls = vector("list", nrow(selected_shape_ids))
for(i in 1:nrow(selected_shape_ids)){
  ls[[i]] = selected_shapes %>% 
    filter(shape_id == selected_shape_ids$shape_id[i]) %>% 
    select(shape_pt_lon, shape_pt_lat) %>% 
    as.matrix()
}
geo2 = st_multilinestring(ls) %>% st_sfc %>% st_sf # have to convert to geometry type, then feature collection for aggregation?

geojson = rbind(geo1, geo2) %>% sf_geojson #combine features from different feature collections, finally!

#abort mission, this part doesn't work as I intended
# leaflet() %>% 
#   addProviderTiles("CartoDB.Positron") %>% 
#   addGeoJSON(geojson)

m = leaflet(stops_cut) %>% 
  addProviderTiles("CartoDB.Positron") %>% 
  addPolylines(lng = ~stop_lon, lat = ~stop_lat)  %>% #trip goes sotuhbound, remember that
  addCircleMarkers(lng = ~stop_lon, lat = ~stop_lat,
    radius = 6,
    color = "red",
    stroke = FALSE, fillOpacity = 0.5,
    popup = ~paste0("Stop: ", stop_id)
  )
m
```


#Broadway inwards
```{r}

#Convert to datetime object
dat$actstoptime = dat$actstoptime %>% 
  as.POSIXct()

#Classify into AM peak (1), midday (2), and PM peak (3)
timeclasses = matrix(
  c("07:30:00", "09:30:00",
  "12:00:00", "14:00:00", #gtfs uses 24 hr clock
  "16:30:00", "18:30:00"),
  nrow = 3, ncol = 2,
  byrow = TRUE
) %>% 
  as.POSIXct(format = "%H:%M:%S") # creates POSIX object with today's date (just make sure it runs on the same day as the other)

dat = dat %>% 
  mutate(time = as.POSIXct(format(actstoptime,"%H%:%M:%S"), format = "%H:%M:%S")) %>% #first, extract time out of the datetime
  mutate(peak = with(.,case_when( #case_when() is better than nested ifelse statements
  (time > timeclasses[1] & time < timeclasses[4]) ~ 1,
  (time > timeclasses[2] & time < timeclasses[5]) ~ 2,
  (time > timeclasses[3] & time < timeclasses[6]) ~ 3,
  TRUE ~ 0))) #all other trips are not analyzed

triptimes = dat %>% 
  group_by(trip) %>% 
  filter(any(stopid %in% 2709) & any(stopid %in% 5303)) %>% # look at length of interest: the full corridor
  filter(any(peak > 0)) %>% 
  summarise(travel_time = max(actstoptime) - min(actstoptime),#calculate stoptime using the first and last stops
            seasonal_period = unique(seasonal_period), 
            implemented = unique(implemented),
            peak = max(peak) )

#results:
triptimes %>% 
  group_by(seasonal_period, peak) %>% 
  summarise(
            mean_imp = median(travel_time[implemented == 1]), 
            sd_imp = sd(travel_time[implemented == 1]),
            mean_noimp = median(travel_time[implemented == 0]),
            sd_noimp = sd(travel_time[implemented == 0])
            )
# I assume that peaks across days are comparable. Could be tested I guess. 


```

```{r}
dat = read.csv(file = 'data/Broadway/R101_out.csv')
endstops = c(2722, 2729)

#Find coordinates of important stops
stopnames = dat %>% select(stopid) %>% unique()
stops_cut = filter(mbta_gtfs$stops, as.numeric(stop_code) %in% stopnames$stopid)

#map out the stops
m = leaflet(stops_cut) %>% 
  addProviderTiles("CartoDB.Positron") %>% 
  addPolylines(lng = ~stop_lon, lat = ~stop_lat)  %>% #trip goes sotuhbound, remember that
  addCircleMarkers(lng = ~stop_lon, lat = ~stop_lat,
    radius = 6,
    color = "red",
    stroke = FALSE, fillOpacity = 0.5
  )
m


#Convert to datetime object
dat$actstoptime = dat$actstoptime %>% 
  as.POSIXct()

dat = dat %>% 
  mutate(time = as.POSIXct(format(actstoptime,"%H%:%M:%S"), format = "%H:%M:%S")) %>% #first, extract time out of the datetime
  mutate(peak = with(.,case_when( #case_when() is better than nested ifelse statements
  (time > timeclasses[1] & time < timeclasses[4]) ~ 1,
  (time > timeclasses[2] & time < timeclasses[5]) ~ 2,
  (time > timeclasses[3] & time < timeclasses[6]) ~ 3,
  TRUE ~ 0))) #all other trips are not analyzed

triptimes = dat %>% 
  group_by(trip) %>% 
  filter(any(stopid %in% endstops[1]) & any(stopid %in% endstops[2])) %>% # look at length of interest: the full corridor
  filter(any(peak > 0)) %>%
  summarise(travel_time = max(actstoptime) - min(actstoptime),#calculate stoptime using the first and last stops
            seasonal_period = unique(seasonal_period), 
            implemented = unique(implemented),
            peak = max(peak) )

#results:
triptimes %>% 
  group_by(seasonal_period, peak) %>% 
  summarise(
            mean_imp = median(travel_time[implemented == 1]), 
            sd_imp = sd(travel_time[implemented == 1]),
            mean_noimp = median(travel_time[implemented == 0]),
            sd_noimp = sd(travel_time[implemented == 0])
            )
#
```

```{r}

```










